# Architecture Diagram: Quantum Pretraining & Warm-Starts

```
┌─────────────────────────────────────────────────────────────────────┐
│                      QAOA TSP SOLVER PIPELINE                        │
└─────────────────────────────────────────────────────────────────────┘

INPUT: TSP Graph (10 nodes, 90 qubits)
    │
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  OPTIONAL STEP 1: QUANTUM PRETRAINING                                │
│  (quantum_pretraining.py)                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  pretrain_and_create_initial_params():                               │
│    ├─ Layer 0: Optimize (γ₀, β₀) for max validity                   │
│    ├─ Layer 1: Optimize (γ₁, β₁) for max validity (optional)        │
│    └─ Layers 2+: Initialize with zeros/random/linear                │
│                                                                       │
│  Output: [γ₀, γ₁, γ₂, β₀, β₁, β₂]  ← custom_initial_params         │
│          Validity rate: ~60-80%                                      │
└─────────────────────────────────────────────────────────────────────┘
    │
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  OPTIONAL STEP 2: WARM-START TOUR GENERATION                         │
│  (opt_helpers.py::get_warm_start_tour)                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  Choose method:                                                      │
│    ┌──────────────────┬──────────────────────────────────┐         │
│    │ nearest_neighbor │ Greedy: always pick nearest      │         │
│    ├──────────────────┼──────────────────────────────────┤         │
│    │ cheapest_ins.    │ Min cost insertion at each step  │         │
│    ├──────────────────┼──────────────────────────────────┤         │
│    │ farthest_ins.    │ Insert farthest nodes first      │         │
│    ├──────────────────┼──────────────────────────────────┤         │
│    │ random_nearest   │ Randomized greedy (top 3)        │         │
│    ├──────────────────┼──────────────────────────────────┤         │
│    │ random           │ Random valid tour                │         │
│    └──────────────────┴──────────────────────────────────┘         │
│                                                                       │
│  Output: [0, 3, 7, 1, 9, 4, 2, 8, 6, 5, 0]  ← warm_start_tour       │
│          Initial tour cost: ~15% better than random                  │
└─────────────────────────────────────────────────────────────────────┘
    │
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  STEP 3: CREATE QAOA CIRCUIT                                         │
│  (quantum_helpers.py)                                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  create_warm_started_qaoa() or create_tsp_qaoa_circuit():           │
│                                                                       │
│  If warm_start provided:                                             │
│    1. Initialize qubits to represent warm-start tour                │
│       |ψ₀⟩ = |tour_bitstring⟩                                        │
│    2. Apply small rotations for exploration                          │
│       RY(exploration_strength) on each qubit                         │
│                                                                       │
│  If no warm_start:                                                   │
│    1. Initialize in equal superposition                              │
│       |ψ₀⟩ = H⊗ⁿ|0⟩ⁿ                                                │
│                                                                       │
│  Then build QAOA layers:                                             │
│    For each layer p = 0 to P-1:                                      │
│      ├─ Cost Hamiltonian: RZ(2γₚ·weight) on each edge qubit        │
│      └─ Mixer Hamiltonian: RX(2βₚ) on each qubit                    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
    │
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  STEP 4: BATCHED SIMULATION                                          │
│  (quantum_helpers.py::simulate_large_circuit_in_batches)            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  Split 90 qubits into batches of 8:                                  │
│    Batch 0: qubits 0-7    ──────┐                                   │
│    Batch 1: qubits 8-15   ──────┤                                   │
│    Batch 2: qubits 16-23  ──────┤                                   │
│    ...                     ...   ├──► Simulate independently        │
│    Batch 10: qubits 80-87 ──────┤                                   │
│    Batch 11: qubits 88-89 ──────┘                                   │
│                                                                       │
│  Combine results into full bitstrings                                │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
    │
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  STEP 5: EVALUATE AND OPTIMIZE                                       │
│  (quantum_engines.py::run_QAOA)                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  For each optimization iteration:                                    │
│    1. Run circuit with current parameters                            │
│    2. Get measurement results (bitstrings + counts)                  │
│    3. Calculate validity rate                                        │
│    4. Calculate cost expectation:                                    │
│         E = Σ (valid_cost · count) + penalty · (invalid_count)      │
│    5. COBYLA updates parameters to minimize E                        │
│    6. Track progress in qaoa_results_over_time                      │
│                                                                       │
│  Output best valid tour found                                        │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
    │
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  OUTPUT: Best TSP Tour                                               │
│                                                                       │
│  graphs_dict[label] = tour_graph                                     │
│  runtime_data[label] = optimization_time                             │
│  tt_data[label] = total_travel_time                                  │
│  qaoa_progress[label] = [stats per iteration]                       │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────┐
│                      CONFIGURATION OPTIONS                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  Configuration 1: BASELINE                                           │
│    warm_start = None                                                 │
│    custom_initial_params = None                                      │
│    → Standard QAOA with random initialization                        │
│    → Validity: ~10-20%                                              │
│                                                                       │
│  Configuration 2: WARM-START ONLY                                    │
│    warm_start = 'nearest_neighbor'                                   │
│    exploration_strength = 0.2                                        │
│    custom_initial_params = None                                      │
│    → Good initial state, standard parameter init                     │
│    → Validity: ~60-90%                                              │
│                                                                       │
│  Configuration 3: PRETRAINING ONLY                                   │
│    warm_start = None                                                 │
│    custom_initial_params = [pretrained params]                       │
│    → Standard initial state, learned parameters                      │
│    → Validity: ~40-80%                                              │
│                                                                       │
│  Configuration 4: COMBINED (BEST)                                    │
│    warm_start = 'cheapest_insertion'                                 │
│    exploration_strength = 0.1                                        │
│    custom_initial_params = [pretrained params]                       │
│    → Good initial state AND learned parameters                       │
│    → Validity: ~70-95%                                              │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────┐
│                    PARAMETER FLOW DIAGRAM                             │
└─────────────────────────────────────────────────────────────────────┘

WITHOUT PRETRAINING:
    get_initial_parameters(strategy='zero')
         ↓
    [0, 0, 0, 0, 0, 0]  ← All zeros
         ↓
    QAOA optimization
         ↓
    [0.23, 0.41, 0.18, 0.52, 0.31, 0.44]  ← Optimized


WITH PRETRAINING:
    pretrain_and_create_initial_params()
         ↓
    Layer 0 pretraining → γ₀=0.15, β₀=0.38  (validity: 65%)
         ↓
    Layer 1 pretraining → γ₁=0.22, β₁=0.41  (validity: 72%)
         ↓
    Extend with zeros → γ₂=0.0, β₂=0.0
         ↓
    [0.15, 0.22, 0.0, 0.38, 0.41, 0.0]  ← Pretrained params
         ↓
    QAOA optimization (starts from better point)
         ↓
    [0.19, 0.25, 0.12, 0.42, 0.45, 0.31]  ← Optimized


┌─────────────────────────────────────────────────────────────────────┐
│                    STATE EVOLUTION DIAGRAM                            │
└─────────────────────────────────────────────────────────────────────┘

STANDARD QAOA:
    |0⟩⊗⁹⁰ ──H⊗⁹⁰──► |+⟩⊗⁹⁰ ──QAOA──► |ψfinal⟩
     ↑                  ↑                 ↑
   start          superposition    optimized state
  (invalid)      (all tours)      (hopefully valid)


WARM-START QAOA:
    |tour⟩ ──RY(ε)──► |tour + δ⟩ ──QAOA──► |ψfinal⟩
      ↑                    ↑                   ↑
   valid tour         slight mixing      improved tour
  (from heuristic)   (exploration)      (near original)


PRETRAINED WARM-START QAOA (COMBINED):
    |tour⟩ ──RY(ε)──► |tour + δ⟩ ──QAOA(θ*)──► |ψfinal⟩
      ↑                    ↑           ↑            ↑
   valid tour         slight      pretrained    best of
  (from heuristic)   mixing      parameters    both worlds
```

## File Dependencies

```
main.py
  │
  ├──► quantum_pretraining.py
  │      ├──► quantum_helpers.py (circuit creation, simulation)
  │      └──► quantum_engines.py (objective function)
  │
  ├──► quantum_engines.py
  │      ├──► quantum_helpers.py (all circuit operations)
  │      └──► opt_helpers.py (tour utilities)
  │
  └──► opt_helpers.py
         └──► (no dependencies)

example_pretraining_and_warmstarts.py
  └──► (same as main.py)

test_pretraining_and_warmstarts.py
  ├──► opt_helpers.py
  ├──► quantum_helpers.py
  └──► quantum_pretraining.py
```
